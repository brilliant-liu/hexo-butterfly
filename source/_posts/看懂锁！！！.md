---
title: '看懂锁！！！'
date: 2020-07-11 20:36:29
tags:
  - java
  - 锁
categories:
  - [java]
cover: 'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2560283127,3256626002&fm=26&gp=0.jpg'
---

# 锁！

> 写在前面： 
>
> 文章内容均来自互联网，加上自己的理解，汇总而成，如若存在错误或者不严谨的地方，还请见谅。文章仅供参考。
>
> 特别感谢马士兵老师的视频讲解，特附上学习视频地址： https://www.bilibili.com/video/BV1xK4y1C7aT?p=3 ，有需要详细了解的可关注马士兵老师。

## CAS

CAS ：Compare and Swap，即比较再交换，也是实现我们平时所说的自旋锁或乐观锁的核心操作。CAS算法实现了区别于synchronouse同步锁的一种乐观锁。下图是CAS的实现原理大致流程

![image.png](https://i.loli.net/2020/07/11/3qJmN2CeOjw96Yx.png)

CAS算法理解：CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。通俗的解释是：就是用一个预期的值和内存值进行比较，如果两个值相等，就用预期的值替换内存值，并返回 true。否则，返回 false。

> 扩展小细节：
>
> **CAS的使用场景：**`java.util.concurrent`包下，比如 CountDownLatch、Semaphore、ReentrantLock 中，再比如 `java.util.concurrent.atomic` 包下的Atomic* ，比如 AtomicBoolean、AtomicInteger 等。
>
> **CAS中的ABA问题：** 其他线程修改数次最后值和原始值相同。解决措施：对原值增加版本号，每次修改更版本号。
>
> CAS操作机制对应的汇编指令：`lock cmpxchg`，`cmpxchg`指令是没有原子性的，搭配`lock`指令在执行的时候会锁定一个北桥信号，从而保证了原子性。



##  Java的内存布局

这里使用的时JVM(HotSpot(TM) 64-Bit)默认开启压缩后的布局及其占用大小。

![image.png](https://i.loli.net/2020/07/11/dIbLDcewyqQU5jn.png)

​		通过代码输出查看新建Object的布局信息：

![image.png](https://i.loli.net/2020/07/11/Euo39yYkOeBxwWq.png)



>扩展：
>
>1. `Object o = new Object()`在开启JVM压缩时在内存中占用16个字节，其中markword占用8个，class pointer占用4个，补位4个。未开启压缩时其中markword占用8个，class pointer占用8个，不需要对齐，还是16个。
>2. Mark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息。
>
>2. 查看JVM是否开启压缩：`java -XX:+PrintCommandLineFlags -version`:
>
>```
>-XX:InitialHeapSize=132425024 -XX:MaxHeapSize=2118800384 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC
>java version "1.8.0_231"
>Java(TM) SE Runtime Environment (build 1.8.0_231-b11)
>Java HotSpot(TM) 64-Bit Server VM (build 25.231-b11, mixed mode)
>```
>
>`-XX:+UseCompressedClassPointers`:压缩指针，默认开启，会把64位的指针8个字节压缩位4个字节。
>
>`-XX:+UseCompressedOops`: 普通对象指针，也会压缩成4个字节
>
>3. 查看Java的内存布局方法：
>
>```
><dependency>
>    <groupId>org.openjdk.jol</groupId>
>    <artifactId>jol-core</artifactId>
>    <version>0.9</version>
></dependency>
>```
>
>```java
>@Test
>public void testss(){
>    Object o = new Object();
>    System.out.println(ClassLayout.parseInstance(o).toPrintable());
>}
>
>```



## 相关锁的概念

### 量级划分

1. 偏向锁

   如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。**偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗**。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。

   “偏向”的意思是，*偏向锁假定将来只有第一个申请锁的线程会使用锁*（不会有任何线程再来申请锁），因此，*只需要在Mark Word中CAS记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功*，记录锁状态为偏向锁，*以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁*。

   偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。

   > 偏向锁在Java6和java7里默认是开启的，但是它是应用程序启动几秒之后才会激活，可以通过`-XX:BiasedLockingStartuoDelay=0 `关闭延迟。通过 `-XX:-UserBiasedLocking=false `关闭偏向锁，那么线程就会默认进入轻量级锁的状态。

   

2. 轻量级锁/自旋锁/自适应自旋锁

   轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。

   使用轻量级锁时，不需要申请互斥量，仅仅*将Mark Word中的部分字节CAS更新指向线程栈中的`Lock Record`，如果更新成功，则轻量级锁获取成功*，记录锁状态为轻量级锁；

   如果目前发生了剧烈的线程竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。

   > 扩展：
   >
   > 轻量级锁也是指自旋锁，自适应自旋锁，其并没有对资源加锁，只是通过CAS操作，实现对资源的访问控制。因此可以视为无锁
   >
   > 通过`-XX:+UseSpinning`来开启自旋锁，JDK1.6后默认开启，并引入自适应自旋锁，由JVM控制，一般不需要设置
   >
   > 首先，内核态与用户态的切换上不容易优化。但**通过自旋锁，可以减少线程阻塞造成的线程切换**（包括挂起线程和恢复线程）。
   >
   > 如果锁的粒度小，那么**锁的持有时间比较短**（尽管具体的持有时间无法得知，但可以认为，通常有一部分锁能满足上述性质）。那么，对于竞争这些锁的而言，因为锁阻塞造成线程切换的时间与锁持有的时间相当，减少线程阻塞造成的线程切换，能得到较大的性能提升。具体如下：
   >
   > - 当前线程竞争锁失败时，打算阻塞自己
   > - 不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会
   > - 在自旋的同时重新竞争锁
   > - 如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己
   >
   > 自旋锁的缺点：
   >
   > - 自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择。
   > - 如果锁竞争的时间比较长，那么自旋通常不能获得锁，白白浪费了自旋占用的CPU时间。

   

3. 重量级锁（Synchronized）

   `synchronized`是Java提供的一个并发控制的关键字，作用于对象，class，方法块上。

   内置锁是JVM提供的最便捷的线程同步工具，在代码块或方法声明上添加synchronized关键字即可使用内置锁。内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。

   > 扩展：
   >
   > `Synchronized`: 独占锁，悲观锁，非公平锁：因为它会无时无刻进行锁住对象，线程之间的切换以及线程从内核态到用户态的时间是耗费性能的。
   >
   > `Synchronized`: 其保证了代码的原子性和可见性以及有序性，但是不会处理重排序以及代码优化的过程，但是在一个线程中执行肯定是有序的，因此是有序的。



###  悲观性划分

1. 悲观锁

   悲观锁是基于一种悲观的态度类来防止一切数据冲突，它是以一种预防的姿态在修改数据之前把数据锁住，然后再对数据进行读写，在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁，然后才可以对数据进行操作，一般数据库本身锁的机制都是基于悲观锁的机制实现的;

   特点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;

   > 扩展
   >
   > `Synchronized`属于悲观锁

2. 乐观锁

   乐观锁是对于数据冲突保持一种乐观态度，操作数据时不会对操作的数据进行加锁（这使得多个任务可以并行的对数据进行操作），只有到数据提交的时候才通过一种机制来验证数据是否存在冲突(一般实现方式是通过加版本号然后进行版本号的对比方式实现);

   特点：乐观锁是一种并发类型的锁，其本身不对数据进行加锁通而是通过业务实现锁的功能，不对数据进行加锁就意味着允许多个请求同时访问数据，同时也省掉了对数据加锁和解锁的过程，这种方式大大的提高了数据操作的性能;

   > 扩展：
   >
   > 乐观锁： 轻量级锁



### 公平性划分

1. **公平锁**

   公平和非公平锁的队列都基于锁内部维护的一个双向链表，表结点Node的值就是每一个请求当前锁的线程。公平锁则在于每次都是依次从队首取值。即公平锁是指多个线程按照申请锁的顺序来获取锁。

2. 非公平锁

   非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

   > 非公平锁：Synchronized



###  重入性划分

1. 可重入锁 

   可重入锁，也叫做递归锁，指的是在同一线程内，外层函数获得锁之后，内层递归函数仍然可以获取到该锁。换一种说法：同一个线程再次进入同步代码时，可以使用自己已获取到的锁。

2.  不可重入锁

   不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。



### 共享性划分

1. 独享锁

   是指该锁只能同时被一个线程持有。

   > `ReentrantLock`是独享锁

2. 共享锁

   指该锁可以同时被多个线程持有。

   > `ReadWriteLock`是一个读的共享锁



### 互斥性划分

1. 互斥锁

   在编程中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。每个对象都对应于一个可称为" 互斥锁" 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。

   共享资源的使用是互斥的，即一个线程获得资源的使用权后就会将改资源加锁，使用完后会将其解锁，所以在使用过程中有其它线程想要获取该资源的锁，那么它就会被阻塞陷入睡眠状态，直到该资源被解锁才会别唤醒，如果被阻塞的资源不止一个，那么它们都会被唤醒，但是获得资源使用权的是第一个被唤醒的线程，其它线程又陷入沉睡。

   

###  读写性划分

1. 读写锁

   读写锁拥有读状态加锁、写状态加锁、不加锁三种状态。只有一个线程可以占有写状态的锁，但可以多个线程同时占有读状态锁，这也是它可以实现高并发的原因。

   > **读写锁三个特征**：
   >
   > - 多个读者可以同时进行读
   > - 写者必须互斥，只允许一个写者写，也不能读者写者同时进行
   > - 写者优先于读者，一旦有写者，则后续读者必须等待，唤醒时优先考虑写者



## 锁的升级过程

> 下面的分析基于64位HotspotJVM

无锁态（创建对象） --》 偏向锁 --》 轻量级锁 --》 重量级锁

java内存布局中的markword存储锁中信息以及占用的字节大小图：

![image.png](https://i.loli.net/2020/07/11/pSkvwJ9YK3gnyiI.png)

​							（图2）

>图2中部分概念的解释：
>
>分代年龄：新生代 ( Young )、老年代 ( Old ) 通过JVM参数`-XX:MaxTenuringThreshold` 可以设置,最大为15，占用三个bit。

锁的升级白话描述：

- 无锁（刚创建对象时）到偏向锁

  把markword的线程ID改为当前访问线程的ID

  > 当一个进程T1过来访问资源R时，发现自己时第一个来访问该资源的进程，于是便把该资源锁的markword中的54位记录下当前线程T1的指针`javaThread*`，同时将偏向锁的锁位由0（无锁状态）改为1（偏向锁状态）。如果该资源R被该线程再次访问，且无其他线程访问过时，则无需加锁，直接允许T1访问。

​						

- 偏向锁升级到自旋锁

  线程在自己的线程栈生成`LockRecoder`，用CAS操作将markword设置为指向自己线程的`LockRecoder`的指针，设置成功则获取到锁

  > 如果存在了多个线程访问资源R，然后立即撤销偏向锁的状态，同时多个线程开始通过CSA机制进行资源R的竞争，先把若线程T1先把线程栈中自己的`lock Recoder`指针记录到轻量级锁中。则T1获取资源访问权，其他线程只能通过自旋的方式等待访问（**消耗CPU性能**）。
  >
  > 



- 自旋锁升级到重量级锁

  如果线程竞争加剧，将markwork设置指向互斥量`mutex`重量级锁的指针。

  > 有线程超过10次自旋（`--XX:PreBLockSpin`），或者自旋线程数超过CPU核数的一半，JDK1.6后，加入自适应自旋锁（Adaptive Self Spinning），由JVM自己控制是否升级为重量级锁。升级重量级锁后，线程需向操作系统申请资源，并进入无序的等待队列（**线程处于wait状态，不消耗CPU**），等待OS的调度，然后再映射回用户空间。

  

> 注意细节：JDK8的对象默认为无锁状态 ，JDK11对象默认为偏向锁。



## 锁消除（lock eliminate） 

锁消除是发生在编译器级别的一种锁优化方式。

例如：

```java
public void add(String str1,String str2){
    StringBuffer sb = new StringBuffer();
    sb.append(str1).append(str2);
}
```

StringBuffer是线程安全的，因为其关键方法都是被`synchronized`修饰过的，上面代码中sb只会再add方法内使用，不可能被其他线程引用（局部变量，栈私有），JVM会自动消除StringBuffer对象内部的锁。





## 锁粗化（lock coarsening）

有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。

例如：

```java
public String test(String str){
    int i=0;
    StringBuffer sb = new StringBuffer();
    while(i<100){
        sb.append(str);
        i++;
    }
    return sb.toString();
}
```

JVM检测到这样一连串的操作，都会对同一个对象加锁一次，而不是100次加锁，JVM会把锁的范围粗化到这一连串的操作外部，使得一连串的操作只需要加锁一次。



## 锁降级

锁降级发生在GC时，该锁不在被任何 线程访问，没有具体的实际意义了。

## Lock锁

Lock锁提供了的比synchronized关键字更加灵活的锁操作，是代码层面的锁操作。

lock锁和Synchronized锁的比较：

| 类型     |                        synchronized锁                        | Lock锁                                                       |
| -------- | :----------------------------------------------------------: | ------------------------------------------------------------ |
| 获取锁   | 无超时时间，未获取到则阻塞等待（占用cpu资源），且无法被中断  | 非阻塞，可以被中断，未获取到则排队，中断，可以自定义超时时间 |
| 共享锁   |                            不支持                            | 读写锁ReadWriteLock支持                                      |
| 释放锁   | synchronized无法获得所得状态，属于自动锁，由当前线程执行完自动释放或者发生异常由JVM自动释放锁 | Lock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。 |
| 读写性   | synchronized关键字无法读写分离，在多个读线程访问临界资源时，是不需要同步的，但是synchronized关键字通通都给同步了，会导致效率很慢 | Lock提供读写锁，实现读写分离；                               |
| 中断性   | synchronized关键字无法响应中断，如果线程未获得锁，便会一直地尝试去获得锁，不会响应中断 | lock锁的lockInterruptibly()方法能让线程响应中断，同时tryLock可以加入时间参数，若一定时间内未获得锁便返回，较为灵活； |
| java类型 | synchronized是java中的一个关键字，也就是说是Java语言内置的特性。 | lock是一个接口是类                                           |


## AQS

### AQS原理

AQS：AbstractQuenedSynchronizer抽象的队列式同步器。它提供了一种实现阻塞锁和一系列依赖FIFO等待队列（双向链表）的同步器的框架。是除了java自带的synchronized关键字之外的锁机制。

AQS，指的是AbstractQueuedSynchronizer，，ReentrantLock、Semaphore、CountDownLatch、CyclicBarrier等并发类均是基于AQS来实现的，具体用法是通过继承AQS实现其模板方法，然后将子类作为同步组件的内部类。

### AQS的核心思想

如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

> CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。
>
> **实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏都是AQS的衍生物**

获取锁的流程：

![AQS流程](https://upload-images.jianshu.io/upload_images/11772136-630de1626ef407e1.png)



### 资源共享方式

AQS 定义了两种资源共享方式：

+ **Exclusive**

  独占，只有一个线程能执行，如ReentrantLock

+ **Share**

  共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier


