---
title: 分布式基石ZK
date: 2020-07-25 19:05:44
tags:
    - zookeeper
    - java
categories:
  - 教程
cover: https://img2018.cnblogs.com/blog/941183/201906/941183-20190614191945691-976367436.png
---


# 分布式基石：zookeeper



## 分布式系统CAP理论

CAP 理论是针对分布式数据库而言的，它是指在一个分布式系统中，一致性（Consistency, C）、可用性（Availability, A）、分区容错性（Partition Tolerance, P）三者不可兼得。

![capimage](https://img2018.cnblogs.com/blog/941183/201906/941183-20190614191945691-976367436.png)

### Consistency 一致性

一致性指的是所有节点在同一时间的数据完全一致。

**对于一致性，一致的程度不同大体可以分为强、弱、最终一致性三类。**

+ 强一致性

  对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。比如小明更新V0到V1，那么小华读取的时候也应该是V1。

+ 弱一致性

  如果能容忍后续的部分或者全部访问不到，则是弱一致性。

+ 最终一致性

  如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。



### Availability可用性

可用性是指“reads and writes always succeed”，即用户访问数据时，系统是否能在正常响应时间返回结果。好的可用性主要是指系统能够很好地为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。

在通常情况下，可用性与分布式数据冗余、负载均衡等有着很大的关联。



### Partition Tolerance 分区容错性

分区容错性是指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。

### CAP的取舍问题

- CA without P

  如果不要求 Partition Tolerance，即不允许分区，则强一致性和可用性是可以保证的。其实分区是始终存在的问题，因此 CA 的分布式系统更多的是允许分区后各子系统依然保持 CA。

+ CP without A

  如果不要求可用性，相当于每个请求都需要在各服务器之间强一致，而分区容错性会导致同步时间无限延长，如此 CP 也是可以保证的。很多传统的数据库分布式事务都属于这种模式。

+ AP without C

  如果要可用性高并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了实现高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。

> 思考： 为什么CAP不能同时满足？
>
> 扩展：
>
> 应用场景：
>
> CA: mysql，Oracle；CP : Redis，Zookeeper ，Hbase； AP：Eureka 



## zookeeper

### 什么是ZK

ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，它是一个为分布式应用提供一致性服务的软件，提供的功能包括：**配置维护、域名服务、分布式同步、组服务**等。

ZooKeeper是以Fast Paxos算法为基础。

> 个人理解：
>
> zookeeper =文件系统+监听通知机制。能够保证数据的一致性问题，是一个有头的（有根目录/）的数据树。

其目录结构大致为：

![zookeeper](https://img-blog.csdn.net/201807121434154)

每个子目录项如 NameService 都被称作为 znode(目录节点)，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。

### znode的类型

- PERSISTENT-持久化目录节点

  客户端与zookeeper断开连接后，该节点依旧存在

- PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点

  客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号

- EPHEMERAL-临时目录节点

  客户端与zookeeper断开连接后，该节点被删除

- EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点

  客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号

### 监听通知机制

客户端注册监听它关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除）时，zookeeper会通知客户端。

### ZK的工作原理

详细内容参考： https://www.cnblogs.com/raphael5200/p/5285583.html



### Zab协议

Zab协议 的全称是 **Zookeeper Atomic Broadcast** （Zookeeper原子广播）。Zab协议是为分布式协调服务Zookeeper专门设计的一种 **支持崩溃恢复** 的 **原子广播协议** ，是Zookeeper保证数据一致性的核心算法。Zab借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法。**它是特别为Zookeeper设计的支持崩溃恢复的原子广播协议**。

**Zookeeper 是通过 Zab 协议来保证分布式事务的最终一致性**。

#### Zab协议模式，

+ 恢复模式（选主）
+ 广播模式（同步）

**Zab 协议的特性**：
 1）Zab 协议需要确保那些**已经在 Leader 服务器上提交（Commit）的事务最终被所有的服务器提交**。
 2）Zab 协议需要确保**丢弃那些只在 Leader 上被提出而没有被提交的事务**。

![zab](https://upload-images.jianshu.io/upload_images/1053629-d32b630b65a7a0b2.png)

#### Zab协议原理

**[参考传送门](https://www.jianshu.com/p/2bceacd60b8a)**： 这个地址很重要，有时间建议好好分析分析。

#### 协议状态切换

当Leader出现崩溃退出或者机器重启，亦或是集群中不存在超过半数的服务器与Leader保存正常通信，Zab就会再一次进入崩溃恢复，发起新一轮Leader选举并实现数据同步。同步完成后又会进入消息广播模式，接收事务请求。



Zab协议要求每个 Leader 都要经历三个阶段：**发现，同步，广播**。

- **发现**：要求zookeeper集群必须选举出一个 Leader 进程，同时 Leader 会维护一个 Follower 可用客户端列表。将来客户端可以和这些 Follower节点进行通信。

- **同步**：Leader 要负责将本身的数据与 Follower 完成同步，做到多副本存储。这样也是提现了CAP中的高可用和分区容错。Follower将队列中未处理完的请求消费完成后，写入本地事务日志中。

- **广播**：Leader 可以接受客户端新的事务Proposal请求，将新的Proposal请求广播给所有的 Follower。

  Zab协议中 Leader 等待 Follower 的ACK反馈消息是指“只要半数以上的Follower成功反馈即可，不需要收到全部Follower反馈”即认为消息发送成功，可以发送 commit 消息。Leader 向所有 Follower 广播 commit 消息，同时自身也会完成事务提交。Follower 接收到 commit 消息后，会将上一条事务提交。

  > 对于所有的节点来说，还有一个选举阶段
  >
  > 选举阶段：
  >
  > 节点在一开始都处于选举节点，只要有一个节点得到超过半数节点的票数，它就可以当选准 Leader，只有到达第三个阶段（也就是同步阶段），这个准 Leader 才会成为真正的 Leader。

  

### zk集群为何是单数

+ 容错

  从数据提交方面：有利于客户端的增删改操作无论访问到了哪台zookeeper服务器，最终都会被转发给leader服务器，再由leader服务器分给zookeeper集群中所有follower服务器去投票（投票指的是在内存中做增删改操作），半数投票通过就被认为操作可执行（commit），否则不可执行。奇数的容错性更好。

+ 防脑裂

  从集群的节点方面：一个zookeeper集群中，可以有多个follower、observer服务器，但是必需只能有一个leader服务器。如果leader服务器挂掉了，剩下的服务器集群会通过半数以上投票选出一个新的leader服务器。奇数的容错性更好



## 分布式锁

为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。而这个分布式协调技术的核心就是来实现这个**分布式锁**。

### 分布式锁应该具备哪些条件

- 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行
- 高可用的获取锁与释放锁
- 高性能的获取锁与释放锁
- 具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）
- 具备锁失效机制，防止死锁
- 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败



### 实现分布式锁的方式

+ 基于数据库实现分布式锁

  原理：依赖于关系型数据库固有的排他性来实现不同进程之间的互斥，例如某个表中的某个字段只能是唯一的如ID。

- 基于 Redis 实现分布式锁

  原理：利用 Redis 的 `setnx` 命令。此命令同样是原子性操作，只有在 `key` 不存在的情况下，才能 `set` 成功。且其还可以指定过期时间，超时不主动释放，系统会自动释放。

- 基于 Zookeeper 实现分布式锁

  原理：当线程1开始对数据进行操作的时候，先在zookeeper服务端创建一个临时节点（根据要操作的数据来创建节点的数据，保证唯一性），然后再去操作数据。直到操作结束，删除临时节点；

  如果线程1正在操作数据，这时线程2也要操作同一个数据，当线程2去zookeeper服务端创建临时节点的时候，发现对应的节点已经被创建，就说明有线程正在操作数据。于是线程2创建节点失败（同一个路径下的节点只能创建一个），从而避免因并发而产生的数据一致性问题；



> [优秀地址传送门](https://baijiahao.baidu.com/s?id=1610572906386264645&wfr=spider&for=pc)


> 写在最后：  
> 文章内容部分来于互联网，自己整理而来，如有错误，还请谅解！







